import React, {Component, PropTypes} from 'react';
import {Box, Header, Icons, Anchor, Menu as GMenu, FormField, Form, CheckBox, Paragraph, Title, Button,
  RadioButton, Layer, Footer} from 'grommet';
const {Download, Close, Play: Preview, Code} = Icons.Base;
import {getDisplayLabel} from '../../util/RecordFormat';
import * as ExplorerActions from '../../actions/explorer';
import { cloneDeep } from 'lodash';
import { MODE, init_style, table_style, styles, defaultPDFDefinition,
  getPreviewStyle, updateValue, translateText } from '../../util/pdfGenerator';
import {Brush, StyleDesigner, NumberInputField} from './PDFWidgets';

class Menu extends GMenu {
  render() {
    return super.render();
  }
}

Menu.propTypes = {
  label: PropTypes.oneOfType([PropTypes.object, PropTypes.string])
};

export default class PDFGenerator extends Component {
  componentWillMount() {
    this.state = {
      pdfDefinition: defaultPDFDefinition,
      mode: MODE.DESIGN,
      fields: this.props.body.fields,
      records: [],
      pdfSettings: {
        styles: _.cloneDeep(styles),
        pageOrientation: 'portrait',
        pageHeader: {
          left: {text: 'Generated by AMB', style: 'text'},
          center: {text: '', style: 'text'},
          right: {text: '', style: 'text'}
        },
        contents: {
          style: 'tableExample',
          layout: 'headerLineOnly',
          header: 'tableHeader',
          text: 'text'
        },
        reportDesc: {
          text: '',
          style: 'subheader'
        },
        pageFooter: {
          left: {text: '', style: 'text'},
          center: {text: '', style: 'text'},
          right: {text:'Date: @date', style: 'text'}
        },
        reportHead:  {
          text: '@title',
          style: 'header'
        }
      },
      new_style: {},
      showLayer: null,
      recordsStart: 1,
      limit: 100,
      showExportLayer: false,
      total: 0
    };
    this.updatePDFSettings = this.updatePDFSettings.bind(this);
    this.updateCode = this.updateCode.bind(this);
    this.updateValue = this.updateValue.bind(this);
    this.preview = this.preview.bind(this);
  }

  componentDidMount() {
    this.preview();

    ExplorerActions.loadRecordsByBody(this.props.body).then((data) => {
      this.setState({ records: data.entities, total: data.count }, this.preview);
    });
  }

  autoPreview() {
    if (!this.state.loading) {
      this.setState({ loading: true });
      if (this.previewTimer) {
        clearTimeout(this.previewTimer);
      }
      this.previewTimer = setTimeout(this.preview, 2000);
    }
  }

  updateCode(event, val = event.target.value) {
    const name = event.target.name;

    let error = '', obj;
    try {
      obj = JSON.parse(val);
    } catch (e) {
      error = e.message;
      obj = val;
    }

    this.state.error = error;
    this.state[name] = obj;
    this.setState(this.state, this.autoPreview);
  }

  updateValue(event, props = {}) {
    const {val = event.target.value, name = event.target.name, state = this.state, callback = ()=> this.setState(this.state)} = props;
    updateValue(event, {val, name, state, callback });
  }

  updatePDFSettings(event, val = event.target.value, name = event.target.name) {
    this.updateValue(event, {
      val, name, state: this.state.pdfSettings,
      callback: () => this.setState(this.state, this.autoPreview)
    });
  }

  translateText(pdfDefinition, records = this.state.records) {
    const settings = this.state.pdfSettings,
      body = this.props.body, fields_state= this.state.fields;

    return translateText(pdfDefinition, {settings, records, body, fields_state});
  }

  preview() {
    let pdfDefinition = this.state.pdfDefinition;
    if (this.state.mode != MODE.CODE) {
      pdfDefinition = this.translateText(pdfDefinition);
    }

    pdfMake.createPdf(cloneDeep(pdfDefinition)).getDataUrl((outDoc) => {
      const lastPDF = document.getElementById('pdfV');
      if (lastPDF) {
        lastPDF.remove();
      }

      const pdfContent = document.createElement('embed');
      pdfContent.id = 'pdfV';
      pdfContent.width = '100%';
      pdfContent.height = '100%';
      pdfContent.src = outDoc;

      document.getElementById('pdfContainer').appendChild(pdfContent);

      this.setState({loading: false});
    });

  }

  download(name = this.props.body.label) {
    this.setState({ downloading: true });
    const body = this.props.body;

    ExplorerActions.loadRecordsByBody(body).then((data) => {
      const dd = this.translateText(this.state.pdfDefinition, data.entities);
      if (dd) {
        pdfMake.createPdf(dd).download(name + '.pdf');
        this.setState({ downloading: false });
      }
    });
  }

  format(pdfDefinition) {
    if (typeof pdfDefinition == 'string') {
      return pdfDefinition;
    }
    const text = JSON.stringify(pdfDefinition);
    let spliters = 0, result = '', inArray = false, splitted = false;
    for (let char of text) {
      result += char;
      if (char == '[') {
        inArray = true;
      } else if (char == ']') {
        inArray = false;
      }
      if (splitted) {
        splitted = false;
        continue;
      }

      if (char == '{') {
        result += '\n' + '\t'.repeat(++spliters);
        splitted = true;
      } else if (char == '}') {
        result = result.slice(0, -1);
        result += '\n' + '\t'.repeat(--spliters);
        result += char;
      } else if (char == ',' && !inArray) {
        result += '\n' + '\t'.repeat(spliters);
        splitted = true;
      }
    }

    return result;
  }

  returnStyleField({label, name, value, styles = this.state.pdfSettings.styles, data = Object.keys(styles), noInput=false}) {
    const styleName = noInput ? name : name + '.style';
    const styleValue = noInput ? value : value.style;

    return (
      <FormField className={noInput ? '' : 'input-field'} label={
          <Box justify='between' direction='row'>
            <span>{label}</span>
            <Menu size='small' label={<span style={getPreviewStyle(styles[styleValue])}>{styleValue}</span>} dropAlign={{top: 'top', right: 'right'}}>
             {data.map((s, index) => <Anchor key={index} onClick={(event) => this.updatePDFSettings(event, s, styleName)}>
              <span style={getPreviewStyle(styles[s])}>{s}</span>
              </Anchor>)}
            </Menu>
          </Box>}>
        {!noInput && <input name={name + '.text'} type="text" onChange={this.updatePDFSettings}
               value={value.text} style={getPreviewStyle(styles[value.style], true)}/>}
      </FormField>
    );
  }

  returnTableStyleField({layout, style, header, text}) {
    return (
      <FormField label='Content Table'>
        <Box direction='row' pad={{horizontal: 'small'}}>
          {this.returnStyleField({label:'Layout:', name: 'contents.layout', value: layout, data: table_style, noInput: true})}
          {this.returnStyleField({label:'Style:', name: 'contents.style', value: style, noInput: true})}
        </Box>
        <Box direction='row' pad={{horizontal: 'small'}}>
          {this.returnStyleField({label:'Header:', name: 'contents.header', value: header, noInput: true})}
          {this.returnStyleField({label:'Text:', name: 'contents.text', value: text, noInput: true})}
        </Box>
      </FormField>
    );
  }

  renderStyleLayer() {
    const name = this.state.showLayer;
    if(name) {
      const closeState = {
        showLayer: null,
        new_style: Object.assign({}, init_style),
        pdfSettings: this.state.pdfSettings
      };

      return (
        <Layer closer={true} onClose={() => this.setState(closeState, this.autoPreview)}>
          <StyleDesigner
            styles={this.state.pdfSettings.styles}
            onConfirm={(styles) => {
              closeState.pdfSettings.styles = styles;
            }}/>
        </Layer>
      );
    }
  }

  renderNumberInput(props) {
    return <NumberInputField state={this.state} updateValue={(event)=>this.updateValue(event)} {...props}/>;
  }

  renderExportLayer() {
    const {recordsStart, limit, showExportLayer, total} = this.state;
    if (showExportLayer) {
      const getRecordNumber = () => {
        if (recordsStart + limit > total) {
          return total - recordsStart;
        } else {
          return limit;
        }
      };

      return (
        <Layer closer={true} onClose={() => this.setState({showExportLayer: false})}>
          <Box flex={true} size='large'>
            <Header><Title>Choose records to export</Title></Header>

            <Form className='no-border strong-label'>
              {this.renderNumberInput({
                label: 'How many records do you want to export?',
                name: 'limit',
                min: 100,
                max: 1000,
                step: 100
              })}
              {this.renderNumberInput({
                label: 'From which record do you want to export?',
                name: 'recordsStart',
                min: 1,
                max: total - 1
              })}
            </Form>

            <Box pad={{horizontal: 'medium'}}>
              <Paragraph size='small'>{'You have '}<strong>{total}</strong>{' records in total.'}</Paragraph>
              <Paragraph
                size='small'>{`You will export records `}<strong>{`${recordsStart} ~ ${getRecordNumber() + recordsStart - 1}`}</strong></Paragraph>
            </Box>

            <Footer justify='end' pad={{vertical: 'medium'}}>
              <Button label={`Export ${getRecordNumber()} records`} primary={true} strong={true} onClick={() => {
                this.download();
                this.setState({showExportLayer: false});
              }}/>
            </Footer>
          </Box>
        </Layer>
      );
    }
  }


  render() {
    const {mode, pdfDefinition, error, pdfSettings, loading} = this.state;

    return (
      <Box pad='small' flex={true}>
        <Header justify='between' size='small'>
          <Box>PDF Generator</Box>
          <Menu direction="row" align="center" responsive={true}>
            <Anchor icon={<Code />} onClick={() => this.setState({ mode: mode == MODE.CODE ? MODE.DESIGN : MODE.CODE })} label={mode}/>
            <Anchor icon={<Brush />} onClick={() => this.setState({showLayer: 'new_style'})} label="Style Designer"/>
            <Anchor icon={<Preview/>} disabled={loading} onClick={loading ? null : this.preview} label='Preview'/>
            <Anchor icon={<Download />} disabled={loading} onClick={() => !loading && this.setState({showExportLayer: true})} label='Export'/>

            <Anchor label='Back' icon={<Close/>} onClick={() => this.props.back()}/>
          </Menu>
        </Header>
        <Box flex={true} direction='row'>
          {mode == MODE.CODE ? <FormField error={error} className='code-panel'>
            <textarea name='pdfDefinition' value={this.format(pdfDefinition)}
                      onChange={this.updateCode}/>
          </FormField> :
            <Box flex={true} style={{maxWidth: '50vw'}} direction='row'>
              <Form className='strong-label flex no-border'>
                <FormField label='Page Header'>
                  <Box direction='row' pad='small'>
                    {this.returnStyleField({label: 'Left', name:"pageHeader.left", value:pdfSettings.pageHeader.left})}
                    {this.returnStyleField({label: 'Center', name:"pageHeader.center", value:pdfSettings.pageHeader.center})}
                    {this.returnStyleField({label: 'Right', name:"pageHeader.right", value:pdfSettings.pageHeader.right})}
                  </Box>
                </FormField>
                <FormField label='Report Body'>
                  <Box pad='small'>
                    {this.returnStyleField({label: 'Header', name:"reportHead", value:pdfSettings.reportHead})}
                    {this.returnStyleField({label: 'Descriptions', name:"reportDesc", value:pdfSettings.reportDesc})}
                    {this.returnTableStyleField(pdfSettings.contents)}
                  </Box>
                </FormField>
                <FormField label='Page Footer'>
                  <Box direction='row' pad='small'>
                    {this.returnStyleField({label: 'Left', name:"pageFooter.left", value:pdfSettings.pageFooter.left})}
                    {this.returnStyleField({label: 'Center', name:"pageFooter.center", value:pdfSettings.pageFooter.center})}
                    {this.returnStyleField({label: 'Right', name:"pageFooter.right", value:pdfSettings.pageFooter.right})}
                  </Box>
                </FormField>
                <FormField label="Page Orientation" className='multi-check'>
                  <RadioButton id='pageOrientation' name='pageOrientation' label='portrait'
                               checked={pdfSettings.pageOrientation == 'portrait'} onChange={(event) => this.updatePDFSettings(event, 'portrait')}/>
                  <RadioButton id='pageOrientation' name='pageOrientation' label='landscape'
                               checked={pdfSettings.pageOrientation == 'landscape'} onChange={(event) => this.updatePDFSettings(event, 'landscape')}/>
                </FormField>
              </Form>
              {/*this.renderStyleSettings()*/}
            </Box>
          }
          <div style={{ width: '50vw' }} id='pdfContainer' />
        </Box>
        {this.renderStyleLayer()}
        {this.renderExportLayer()}
      </Box>
    );
  }
}

PDFGenerator.propTyps = {
  body: PropTypes.object.required
};
